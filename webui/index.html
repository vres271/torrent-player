<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Torrent Player</title>
    <style>
        body {
            font-family: sans-serif;
        }

        .row {
            margin: 10px 0;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        input {
            width: 420px;
            padding: 6px;
        }

        input[type="checkbox"] {
            width: auto;
        }

        button {
            padding: 6px 12px;
        }

        pre {
            background: #111;
            color: #ddd;
            padding: 12px;
            border-radius: 6px;
            overflow: auto;
        }

        .ok {
            color: #0a0;
        }

        .bad {
            color: #b00;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 10px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 6px 8px;
            vertical-align: top;
        }

        th {
            background: #f4f4f4;
            text-align: left;
            position: sticky;
            top: 0;
        }

        .muted {
            color: #666;
            font-size: 12px;
        }

        .name {
            max-width: 720px;
        }

        .tlinks {
            display: flex;
            justify-content: space-around;
        }
    </style>
</head>

<body>
    <h3>Connectivity test</h3>

    <div class="row">
        <button id="btnTest">Test</button>
        <span id="testStatus"></span>
    </div>

    <pre id="testOut"></pre>

    <hr>

    <h3>TorAPI search</h3>

    <div class="row">
        <input id="q" placeholder="Часть названия фильма..." />
        <button id="btnSearch">Search</button>
        <label style="user-select:none;">
            <input type="checkbox" id="onlyVideo" checked> Only video
        </label>
        <button id="btnRaw">Show raw JSON</button>
        <span id="searchStatus"></span>
    </div>

    <div class="muted" id="searchMeta"></div>

    <div id="tableWrap"></div>
    <pre id="searchOut" style="display:none;"></pre>

    <script>
        const testOut = document.getElementById('testOut');
        const testStatus = document.getElementById('testStatus');

        const searchOut = document.getElementById('searchOut');
        const searchStatus = document.getElementById('searchStatus');
        const searchMeta = document.getElementById('searchMeta');
        const tableWrap = document.getElementById('tableWrap');
        const q = document.getElementById('q');
        const onlyVideo = document.getElementById('onlyVideo');


        let lastRaw = null;

        async function prettyJson(url) {
            const r = await fetch(url);
            const t = await r.text();
            try { return JSON.stringify(JSON.parse(t), null, 2); }
            catch { return t; }
        }

        function parseSizeToBytes(sizeStr) {
            if (!sizeStr) return 0;
            // normalize: replace NBSP, commas, multiple spaces
            const s = String(sizeStr).replace(/\u00A0/g, ' ').replace(',', '.').trim();
            // e.g. "2.85 GB", "396.4 MB", "428 MB", "65.3 MB"
            const m = s.match(/([\d.]+)\s*([KMGTP]?B)/i);
            if (!m) return 0;
            const num = Number(m[1]);
            const unit = m[2].toUpperCase();
            const mult = { B: 1, KB: 1024, MB: 1024 ** 2, GB: 1024 ** 3, TB: 1024 ** 4, PB: 1024 ** 5 };
            return Math.round((Number.isFinite(num) ? num : 0) * (mult[unit] || 1));
        }

        function isProbablyVideo(item) {
            const cat = String(item.Category || '').toLowerCase();
            const name = String(item.Name || '').toLowerCase();
            const text = cat + ' ' + name;

            // явные не-видео
            const nonVideo = [
                'саундтрек', 'soundtrack',
                'mp3', 'flac', 'aac', 'music',
                'аудиокнига', 'audiobook',
                'pdf', 'djvu','xbox',
                'software',  'linux', 'macos',
                'RePack', 'amd64', 'Portable', 'DLCs',

                // 'windows',
                // 'книга', 'book', 'epub', 'mobi', 
                // 'игра', 'game', 'ps',  'switch',
                // 'софт', 'ost', 'score',
            ];

            if (nonVideo.some(w => text.includes(w))) return false;

            // явные “видео” маркеры (если хочешь жёстче — сделаем обязательными)
            const videoHints = [
                'hdrip', 'bdrip', 'bluray', 'web-dl', 'webrip', 'dvdrip',
                'hdtv', 'uhd', '4k', '1080', '720',
                'x264', 'x265', 'hevc', 'avc',
                'remux', 'imaxi', 'imax', 'dts', 'ac3'
            ];

            // Если категория пустая/странная — но есть видео-hints, считаем видео
            if (videoHints.some(w => text.includes(w))) return true;

            // Если нет явных nonVideo — оставляем (мягкий фильтр)
            return true;
        }

        async function onMagnetClick(ev, provider, id) {
            ev.preventDefault();
            ev.stopPropagation();

            if (!provider || !id) {
                alert("No provider/id for magnet");
                return;
            }

            const url = `/api/magnet?provider=${encodeURIComponent(provider)}&id=${encodeURIComponent(id)}`;

            try {
                const r = await fetch(url);

                let raw;
                const ct = (r.headers.get("content-type") || "").toLowerCase();
                if (ct.includes("application/json")) raw = await r.json();
                else {
                    const text = await r.text();
                    try { raw = JSON.parse(text); } catch { raw = { ok: false, error: text }; }
                }

                if (!r.ok) throw new Error(raw?.error || `HTTP ${r.status}`);
                if (!raw?.ok) throw new Error(raw?.error || "magnet error");

                const magnet = raw.magnet;
                if (!magnet) throw new Error("No magnet in response");

                // Открываем magnet: (запуск ассоциированного приложения)
                window.location.href = magnet;
            } catch (e) {
                alert(String(e?.message || e));
            }
        }

        async function addToQb(ev, provider, id) {
            ev.preventDefault();
            const qbUrl = `/api/qb/add?provider=${encodeURIComponent(provider)}&id=${encodeURIComponent(id)}`;
            const r = await fetch(qbUrl);
            const res = await r.json();
            r.ok ? alert("✅ Added to qB") : alert(`❌ qB: ${res.body}`);
        }


        function esc(s) {
            return String(s ?? '').replace(/[&<>"']/g, ch => ({
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
            }[ch]));
        }

        function renderTable(items) {
            if (!items.length) {
                tableWrap.innerHTML = "<div>Ничего не найдено.</div>";
                return;
            }

            const rows = items.map((x, i) => {
                const localTorrent = x.Torrent ? `/api/torrent?url=${encodeURIComponent(x.Torrent)}` : '';


                return `
            <tr>
                <td>${i + 1}</td>
                <td>${esc(x.provider)}</td>
                <td class="name">${esc(x.Name)}</td>
                <td>${esc(x.Size || '')}</td>
                <td>${esc(x.Seeds ?? '')}</td>
                <td>${esc(x.Peers ?? '')}</td>
                <td>${esc(x.Date ?? '')}</td>
                <td>${x.Url ? `<a href="${esc(x.Url)}" target="_blank" rel="noreferrer">topic</a>` : ''}</td>
                <td>
                    <div  class="tlinks">
                        ${x.Torrent ? `<a href="${esc(x.Torrent)}" target="_blank" rel="noreferrer" title="Torrent file">F</a>` : ''}
                        ${x.Id ? ` <a href="#" title="Get magnet" onclick="onMagnetClick(event,'${esc(x.provider)}','${esc(x.Id)}')">M</a>` : ''}
                        ${x.Id ? ` <a href="#" title="Add to qB" onclick="addToQb(event,'${esc(x.provider)}','${esc(x.Id)}')">Q</a>` : ''}
                    </div>
                </td>
            </tr>
            `
            }).join('');

            tableWrap.innerHTML = `
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Provider</th>
                <th>Name</th>
                <th>Size</th>
                <th>Seeds</th>
                <th>Peers</th>
                <th>Date</th>
                <th>Url</th>
                <th>Torrent</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        `;
        }

        function flattenTorApiResponse(raw) {
            // Поддерживаем оба варианта:
            // 1) webui проксирует и отдаёт { ok, provider, query, data: <TorAPI response> }
            // 2) webui отдаёт сразу { ok, provider, query, data: { RuTracker:[...] ... } } (как у тебя)
            const data = (raw && raw.data && raw.data.RuTracker !== undefined) ? raw.data
                : (raw && raw.data && raw.data.data) ? raw.data.data
                    : null;

            if (!data || typeof data !== 'object') return [];

            const out = [];
            for (const [provider, val] of Object.entries(data)) {
                if (Array.isArray(val)) {
                    for (const item of val) out.push({ provider, ...item });
                } else {
                    // например: NoNameClub: { Result: "..." }
                    // просто игнорируем как "ошибку провайдера"
                }
            }
            return out;
        }

        document.getElementById('btnTest').onclick = async () => {
            testStatus.textContent = 'Testing...';
            testOut.textContent = '';
            try {
                testOut.textContent = await prettyJson('/api/test');
                testStatus.textContent = 'OK';
                testStatus.className = 'ok';
            } catch (e) {
                testStatus.textContent = 'ERROR';
                testStatus.className = 'bad';
                testOut.textContent = String(e?.message || e);
            }
        };

        document.getElementById('btnRaw').onclick = async () => {
            searchOut.style.display = 'block';
            tableWrap.innerHTML = '';
            searchMeta.textContent = '';
            searchOut.textContent = lastRaw ? JSON.stringify(lastRaw, null, 2) : 'No data yet';
        };

        document.getElementById('btnSearch').onclick = async () => {
            const query = q.value.trim();
            if (!query) {
                searchStatus.textContent = 'Enter query';
                searchStatus.className = 'bad';
                return;
            }

            searchStatus.textContent = 'Searching...';
            searchStatus.className = '';
            searchMeta.textContent = '';
            searchOut.style.display = 'none';
            searchOut.textContent = '';
            tableWrap.innerHTML = '';

            try {
                const url = '/api/search?q=' + encodeURIComponent(query) + '&provider=all';
                const r = await fetch(url);
                const raw = await r.json();
                lastRaw = raw;

                if (!raw.ok) {
                    searchStatus.textContent = 'ERROR';
                    searchStatus.className = 'bad';
                    searchOut.style.display = 'block';
                    searchOut.textContent = JSON.stringify(raw, null, 2);
                    return;
                }

                let items = flattenTorApiResponse(raw);

                if (onlyVideo.checked) {
                    items = items.filter(isProbablyVideo);
                }

                items.forEach(x => x.__bytes = parseSizeToBytes(x.Size));
                items.sort((a, b) => (b.__bytes - a.__bytes));


                searchMeta.textContent = `Found: ${items.length} items. Sorted by Size (desc).`;
                renderTable(items);

                searchStatus.textContent = 'OK';
                searchStatus.className = 'ok';
            } catch (e) {
                searchStatus.textContent = 'ERROR';
                searchStatus.className = 'bad';
                searchOut.style.display = 'block';
                searchOut.textContent = String(e?.message || e);
            }
        };
    </script>
</body>

</html>